import fs from 'fs'; // Use standard fs for createWriteStream
import path from 'path';
import fsp from 'fs/promises'; // Use fs/promises for mkdir
/**
 * Aggregates markdown content chunks into a single output file stream.
 * Handles writing separators with source attribution and stream management.
 */
export class Aggregator {
    writeStream = null;
    outputPath;
    streamClosed = false;
    openPromise = null; // To track async setup
    /**
     * Creates an instance of Aggregator, ensures the directory exists,
     * and opens the write stream immediately.
     * @param outputPath The absolute path to the output file.
     */
    constructor(outputPath) {
        this.outputPath = outputPath;
        this.openPromise = this.initializeStream();
    }
    /**
     * Asynchronously ensures directory exists and opens the stream.
     */
    async initializeStream() {
        try {
            await fsp.mkdir(path.dirname(this.outputPath), { recursive: true });
            this.writeStream = fs.createWriteStream(this.outputPath);
            this.writeStream.on('error', (err) => {
                console.error(`[${new Date().toISOString()}] Error writing to aggregator stream ${this.outputPath}:`, err);
                this.streamClosed = true;
                this.writeStream = null;
            });
            // Indicate successful opening for addChunk to wait on
            console.error(`[${new Date().toISOString()}] Aggregator stream opened for ${this.outputPath}`);
        }
        catch (err) {
            console.error(`[${new Date().toISOString()}] Failed to initialize aggregator stream ${this.outputPath}:`, err);
            this.streamClosed = true; // Mark as unusable
            throw err; // Re-throw initialization error
        }
    }
    // ensureStreamIsOpen is replaced by awaiting this.openPromise in addChunk
    // Removed duplicated error handling logic from lines 47-53
    /**
     * Adds a chunk of markdown content to the output file.
     * Includes a separator with the source identifier.
     * Handles stream backpressure.
     * @param markdown The markdown content to add.
     * @param sourceIdentifier A string identifying the source of the markdown (e.g., URL or file path).
     */
    async addChunk(markdown, sourceIdentifier) {
        if (this.streamClosed) { // Check if stream failed during init or runtime
            console.error(`[${new Date().toISOString()}] Stream is closed/errored, cannot add chunk from ${sourceIdentifier}`);
            return;
        }
        await this.openPromise; // Ensure initialization is complete before writing
        if (!this.writeStream) { // Should not happen if openPromise resolved and not closed, but safety check
            console.error(`[${new Date().toISOString()}] Stream is unexpectedly null after initialization for ${this.outputPath}`);
            this.streamClosed = true; // Mark as failed
            return;
        }
        const separator = `\n\n---\nSource: ${sourceIdentifier}\n---\n\n`;
        const contentToWrite = separator + markdown;
        const canWrite = this.writeStream.write(contentToWrite);
        if (!canWrite) {
            // Handle backpressure: wait for the 'drain' event
            await new Promise(resolve => {
                this.writeStream.once('drain', resolve);
            });
        }
    }
    /**
     * Closes the write stream gracefully.
     * Returns a promise that resolves when the stream is fully closed.
     */
    async close() {
        if (this.writeStream && !this.streamClosed) {
            this.streamClosed = true;
            return new Promise((resolve, reject) => {
                this.writeStream.end((err) => {
                    if (err) {
                        console.error(`[${new Date().toISOString()}] Error closing aggregator stream ${this.outputPath}:`, err);
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                    this.writeStream = null; // Clear stream reference after closing
                });
            });
        }
        // If stream was never opened or already closed/errored, resolve immediately
        return Promise.resolve();
    }
}
