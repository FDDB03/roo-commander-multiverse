import TurndownService from 'turndown';
import { execSync, spawn } from 'child_process';
import fsp from 'fs/promises';
import os from 'os';
import path from 'path';
// Initialize Turndown Service with basic options
// Consider customizing if specific HTML-to-Markdown conversions are needed
const turndownService = new TurndownService({
    headingStyle: 'atx', // Use '#' for headings
    codeBlockStyle: 'fenced', // Use ``` for code blocks
    bulletListMarker: '*' // Use '*' for bullet lists
});
let pandocAvailable = undefined;
/**
 * Checks if pandoc command is available on the system PATH.
 * Caches the result to avoid repeated checks.
 */
async function checkPandocAvailability() {
    if (pandocAvailable !== undefined) {
        return pandocAvailable;
    }
    try {
        // Use spawn to avoid shell interpretation issues and capture output/errors separately
        const pandoc = spawn('pandoc', ['--version']);
        let stdout = '';
        let stderr = '';
        pandoc.stdout.on('data', (data) => { stdout += data; });
        pandoc.stderr.on('data', (data) => { stderr += data; });
        const exitCode = await new Promise((resolve) => {
            pandoc.on('close', resolve);
            pandoc.on('error', () => resolve(-1)); // Handle case where pandoc isn't found at all
        });
        if (exitCode === 0 && stdout.toLowerCase().includes('pandoc')) {
            console.error(`[${new Date().toISOString()}] Pandoc found on system.`);
            pandocAvailable = true;
        }
        else {
            console.error(`[${new Date().toISOString()}] Pandoc not found or validation failed (Exit code: ${exitCode}). Will use JS/LLM fallbacks if configured.`);
            pandocAvailable = false;
        }
    }
    catch (error) {
        console.error(`[${new Date().toISOString()}] Error checking for Pandoc:`, error);
        pandocAvailable = false;
    }
    return pandocAvailable;
}
/**
 * Converts content from a given format (html, rst, asciidoc, md) to Markdown.
 * Uses Turndown for HTML.
 * Attempts to use Pandoc (if available) for RST and AsciiDoc.
 * Provides optional fallbacks (e.g., JS libraries or LLM calls - not implemented here).
 *
 * @param content The raw content string.
 * @param format The format of the input content ('html', 'rst', 'asciidoc', 'md').
 * @param sourceIdentifier A string identifying the source (URL/file path) for logging.
 * @returns A promise resolving to the converted Markdown string.
 * @throws An error if conversion fails and no fallback is successful.
 */
export async function convertContentToMarkdown(content, format, sourceIdentifier) {
    console.error(`[${new Date().toISOString()}] Converting ${format} content from ${sourceIdentifier}`);
    if (format === 'md') {
        return content; // No conversion needed
    }
    if (format === 'html') {
        try {
            const markdown = turndownService.turndown(content);
            return markdown;
        }
        catch (error) {
            console.error(`[${new Date().toISOString()}] Turndown conversion failed for ${sourceIdentifier}:`, error);
            throw new Error(`HTML to Markdown conversion failed for ${sourceIdentifier}`);
        }
    }
    if (format === 'rst' || format === 'asciidoc') {
        const hasPandoc = await checkPandocAvailability();
        if (hasPandoc) {
            let tempInputDir = null;
            try {
                // Create a temporary file to hold the input content
                tempInputDir = await fsp.mkdtemp(path.join(os.tmpdir(), `pandoc-convert-${format}-`));
                const tempInputFile = path.join(tempInputDir, `input.${format}`);
                await fsp.writeFile(tempInputFile, content);
                console.error(`[${new Date().toISOString()}] Attempting Pandoc conversion: ${tempInputFile} -f ${format} -t markdown`);
                // Execute pandoc
                // Using execSync for simplicity here, consider spawn for better error/output handling if needed
                const markdown = execSync(`pandoc "${tempInputFile}" -f ${format} -t markdown`, { encoding: 'utf-8' });
                return markdown;
            }
            catch (error) {
                console.error(`[${new Date().toISOString()}] Pandoc conversion failed for ${sourceIdentifier} (${format}):`, error);
                // Fall through to potentially try JS/LLM fallbacks, or throw if none are available
            }
            finally {
                // Ensure temporary directory is cleaned up
                if (tempInputDir) {
                    await fsp.rm(tempInputDir, { recursive: true, force: true }).catch(rmErr => {
                        console.error(`[${new Date().toISOString()}] Failed to remove temp directory ${tempInputDir}:`, rmErr);
                    });
                }
            }
        }
        // --- Fallback mechanisms (Optional) ---
        // if (format === 'rst') {
        //     // Try rst-js library if added
        // } else if (format === 'asciidoc') {
        //     // Try asciidoctor.js if added
        // }
        // if (!converted) {
        //     // Try LLM conversion if configured
        // }
        // If pandoc wasn't available or failed, and no other fallbacks worked
        throw new Error(`Conversion from ${format} requires Pandoc or a suitable JS library/LLM fallback, which was not available or failed for ${sourceIdentifier}.`);
    }
    // Should not be reached if format is one of the expected types
    throw new Error(`Unsupported format "${format}" provided for conversion.`);
}
