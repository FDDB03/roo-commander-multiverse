import fsp from 'fs/promises';
import path from 'path';
import os from 'os';
// Explicitly try the named import for the factory function
import { simpleGit } from 'simple-git';
import { glob } from 'glob';
import { convertContentToMarkdown } from './converter.js'; // Assuming correct path
/**
 * Processes a single file found within the cloned Git repository.
 * Reads the file, determines its format, converts it to Markdown, and adds it to the aggregator.
 *
 * @param absoluteFilePath Absolute path to the file within the temporary clone directory.
 * @param rootTempDir Absolute path to the root of the temporary clone directory.
 * @param aggregator The Aggregator instance to add content to.
 */
async function processGitFile(absoluteFilePath, rootTempDir, aggregator) {
    // Use path relative to temp dir root for clearer source identification,
    // although absolute might be safer if source id is used elsewhere.
    const relativePath = path.relative(rootTempDir, absoluteFilePath);
    console.error(`[${new Date().toISOString()}] Processing git file: ${relativePath}`);
    try {
        const extension = path.extname(absoluteFilePath).toLowerCase();
        let format = null; // Allow 'html' as potential source
        switch (extension) {
            case '.md':
            case '.markdown':
                format = 'md';
                break;
            case '.rst':
                format = 'rst';
                break;
            case '.adoc':
            case '.asciidoc':
                format = 'asciidoc';
                break;
            case '.htm':
            case '.html':
                format = 'html';
                break;
            default:
                console.warn(`[${new Date().toISOString()}] Skipping file with unsupported extension ${extension}: ${relativePath}`);
                return; // Skip unsupported files
        }
        if (format) {
            // Ensure encoding is utf-8, handle potential large files if necessary (streaming read?)
            const rawContent = await fsp.readFile(absoluteFilePath, 'utf-8');
            const markdown = await convertContentToMarkdown(rawContent, format, relativePath); // Pass relative path as source id
            await aggregator.addChunk(markdown, relativePath); // Add converted content
        }
    }
    catch (error) {
        console.error(`[${new Date().toISOString()}] Error processing git file ${relativePath}:`, error);
        // Log error but continue processing other files
    }
}
/**
 * Processes a documentation source hosted in a Git repository.
 * Clones the repo, finds relevant files, and processes them concurrently.
 *
 * @param args Parsed arguments for the generate_llms_full_txt tool.
 * @param limit The concurrency limiter instance.
 * @param aggregator The Aggregator instance to add content to.
 */
export async function processGitSource(args, limit, aggregator) {
    let tempDir = null;
    try {
        // 1. Create temporary directory
        tempDir = await fsp.mkdtemp(path.join(os.tmpdir(), 'llms-git-clone-'));
        console.error(`[${new Date().toISOString()}] Created temp directory for git clone: ${tempDir}`);
        // 2. Clone the repository (shallow clone)
        // Define options cleanly
        const gitOptions = {
            baseDir: tempDir, // Operate within the temp directory
            binary: 'git',
            maxConcurrentProcesses: args.concurrency, // Use configured concurrency
        };
        // Instantiate using the named import 'simpleGit'
        const git = simpleGit(gitOptions);
        console.error(`[${new Date().toISOString()}] Cloning repository ${args.url} into ${tempDir}`);
        // Clone into the baseDir (.), using the options object for flags
        await git.clone(args.url, '.', { '--depth': 1 });
        console.error(`[${new Date().toISOString()}] Repository cloned successfully.`);
        // 3. Find documentation files using glob
        const searchPatterns = args.include_patterns_git;
        const ignorePatterns = args.exclude_patterns_git;
        console.error(`[${new Date().toISOString()}] Searching for files matching: [${searchPatterns.join(', ')}] excluding: [${ignorePatterns.join(', ')}]`);
        // Ensure glob options match expected behavior (e.g., dot files)
        const files = await glob(searchPatterns, {
            cwd: tempDir,
            ignore: ignorePatterns,
            nodir: true, // Only match files
            absolute: true, // Get absolute paths for reading
            dot: true, // Match dotfiles if not explicitly excluded
        });
        console.error(`[${new Date().toISOString()}] Found ${files.length} candidate files.`);
        // 4. Process files concurrently using p-limit
        const processingPromises = files.map(filePath => limit(() => processGitFile(filePath, tempDir, aggregator)) // Pass tempDir root
        );
        const results = await Promise.allSettled(processingPromises);
        // Log any errors from individual file processing
        results.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`[${new Date().toISOString()}] Error processing file ${path.relative(tempDir, files[index])} during settlement:`, result.reason);
            }
        });
        console.error(`[${new Date().toISOString()}] Finished processing all discovered git files.`);
    }
    catch (cloneError) {
        console.error(`[${new Date().toISOString()}] Failed to clone or process Git repository ${args.url}:`, cloneError);
        throw new Error(`Git repository processing failed: ${cloneError.message}`); // Re-throw to indicate failure
    }
    finally {
        // 5. Clean up temporary directory
        if (tempDir) {
            console.error(`[${new Date().toISOString()}] Cleaning up temporary directory: ${tempDir}`);
            await fsp.rm(tempDir, { recursive: true, force: true }).catch(rmError => {
                // Log cleanup error but don't let it hide the primary clone/processing error
                console.error(`[${new Date().toISOString()}] Warning: Failed to remove temporary directory ${tempDir}:`, rmError);
            });
        }
    }
}
