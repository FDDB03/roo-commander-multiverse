import { z } from 'zod';
import { getQdrantClient, isQdrantConfigured } from '../qdrant_client.js';
import { McpError, ErrorCode } from "@modelcontextprotocol/sdk/types.js";
// Removed SearchRequest import
// Input Schema
export const SearchQdrantPointsInputSchema = z.object({
    collection_name: z.string().min(1).describe("The name of the Qdrant collection to search in."),
    vector: z.array(z.number()).describe("The query vector for semantic search."),
    limit: z.number().int().positive().optional().default(10).describe("The maximum number of results to return."),
    filter: z.record(z.any()).optional().describe("Optional Qdrant filter object to apply to the search."),
    score_threshold: z.number().optional().describe("Optional threshold for the similarity score."),
    with_payload: z.boolean().optional().default(true).describe("Whether to include the payload in the search results."),
    with_vector: z.boolean().optional().default(false).describe("Whether to include the vector in the search results."),
}).describe("Input for searching points in a Qdrant collection using a query vector.");
// Output Schema (Array of search results)
// Define schema for a single search hit
const SearchResultSchema = z.object({
    id: z.union([z.string().uuid(), z.number().int()]).describe("ID of the found point."),
    version: z.number().int().describe("Version of the point."),
    score: z.number().describe("Similarity score."),
    payload: z.record(z.any()).optional().describe("Payload of the point (if requested)."),
    vector: z.array(z.number()).optional().describe("Vector of the point (if requested)."),
    // shard_key: z.union([z.string(), z.number().int()]).optional().nullable().describe("Shard key of the point (if using sharding).") // Add if needed
}).describe("A single search result hit.");
const SearchQdrantPointsOutputSchema = z.object({
    results: z.array(SearchResultSchema).describe("An array of search result points."),
}).describe("Output containing the search results from Qdrant.");
// Tool Implementation
async function searchQdrantPointsHandler(input) {
    if (!isQdrantConfigured()) {
        throw new McpError(ErrorCode.InternalError, "Qdrant client is not configured. Set QDRANT_URL environment variable.");
    }
    const client = getQdrantClient();
    const { collection_name, vector, limit, filter, score_threshold, with_payload, with_vector } = input;
    // Construct the search request object (type is inferred by the client method)
    const searchRequest = {
        vector: vector,
        limit: limit,
        filter: filter, // Pass filter object directly
        score_threshold: score_threshold,
        with_payload: with_payload,
        with_vector: with_vector,
        // params: {} // Add HNSW ef search param here if needed, e.g., params: { ef: 128 }
    };
    try {
        console.log(`Searching Qdrant collection '${collection_name}'...`);
        const searchResults = await client.search(collection_name, searchRequest);
        console.log(`Found ${searchResults.length} results from Qdrant.`);
        // Map the results to conform strictly to our SearchResultSchema, especially handling the vector type
        const mappedResults = searchResults.map(hit => ({
            id: hit.id,
            version: hit.version,
            score: hit.score,
            // Ensure payload is a record or undefined
            payload: (hit.payload && typeof hit.payload === 'object') ? hit.payload : undefined,
            // Ensure vector is number[] or undefined, handling null or other types
            vector: (hit.vector && Array.isArray(hit.vector) && hit.vector.every(n => typeof n === 'number')) ? hit.vector : undefined,
        }));
        return { results: mappedResults };
    }
    catch (error) {
        console.error(`Error searching Qdrant collection '${collection_name}':`, error);
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        throw new McpError(ErrorCode.InternalError, `Failed to search Qdrant collection '${collection_name}': ${errorMessage}`);
    }
}
// Export the handler function for use in index.ts
export { searchQdrantPointsHandler };
// Note: No ToolDefinition exported. Integration via index.ts.
