import * as fs from 'node:fs/promises';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { FunctionDeclarationSchemaType } from "@google-cloud/vertexai";
import { sanitizePath } from './utils.js';
import { WORKSPACE_ROOT } from './config.js';
const execAsync = promisify(exec);
// --- Server-Side Function Implementations ---
export async function readFileContent(filePath) {
    try {
        const safePath = sanitizePath(filePath);
        console.error(`[Function Call] Reading file: ${safePath}`);
        const content = await fs.readFile(safePath, 'utf-8');
        // Truncate very large files to avoid overwhelming the LLM context (Increased limit)
        const MAX_FILE_LENGTH = 1000000; // ~1M chars
        return content.length > MAX_FILE_LENGTH
            ? content.substring(0, MAX_FILE_LENGTH) + "\n... (file truncated)"
            : content;
    }
    catch (error) {
        console.error(`[Function Call] Error reading file ${filePath}:`, error);
        return `Error reading file: ${error.message}`;
    }
}
export async function listDirectory(dirPath, recursive = false) {
    try {
        const safePath = sanitizePath(dirPath);
        console.error(`[Function Call] Listing directory: ${safePath} (recursive: ${recursive})`);
        // Simple non-recursive implementation for now
        if (recursive) {
            console.warn("[Function Call] Recursive listDirectory not implemented, listing top-level only.");
        }
        const entries = await fs.readdir(safePath, { withFileTypes: true });
        const result = entries.map(entry => `${entry.name}${entry.isDirectory() ? '/' : ''}`).join('\n');
        return result || "(empty directory)";
    }
    catch (error) {
        console.error(`[Function Call] Error listing directory ${dirPath}:`, error);
        return `Error listing directory: ${error.message}`;
    }
}
export async function searchCodebase(searchTerm, filePattern, caseSensitive = false) {
    try {
        // Basic sanitization - improve this significantly for production use
        const term = searchTerm.replace(/[`$&|;()<>]/g, ''); // Remove more shell metacharacters
        const pattern = filePattern ? filePattern.replace(/[`$&|;()<>]/g, '') : '*';
        const caseFlag = caseSensitive ? '' : '-i';
        // Use rg (ripgrep) if available, fallback to grep. rg is generally safer and faster.
        // Ensure rg/grep is installed on the system where the server runs.
        // Added --max-count 100 to limit results further
        const command = `command -v rg &> /dev/null && rg ${caseFlag} --max-count 100 --glob '${pattern}' --glob '!node_modules' --glob '!.git' -n -e "${term}" . || grep ${caseFlag} -r -n --include='${pattern}' -m 100 --exclude-dir=node_modules --exclude-dir=.git -e "${term}" .`;
        console.error(`[Function Call] Searching codebase with command: ${command}`);
        const { stdout, stderr } = await execAsync(command, { cwd: WORKSPACE_ROOT, timeout: 20000 }); // 20s timeout
        if (stderr)
            console.error(`[Function Call] Search stderr: ${stderr}`);
        const MAX_SEARCH_RESULT_LENGTH = 10000; // Limit output size
        return stdout.length > MAX_SEARCH_RESULT_LENGTH
            ? stdout.substring(0, MAX_SEARCH_RESULT_LENGTH) + "\n... (search results truncated)"
            : (stdout || "(no results found)");
    }
    catch (error) {
        // Exit code 1 often means no matches found for grep/rg
        if (error.code === 1 && !error.stderr)
            return "(no results found)";
        console.error(`[Function Call] Error searching codebase for "${searchTerm}":`, error);
        return `Error searching codebase: ${error.message}`;
    }
}
export async function getGitDiff(staged = false) {
    try {
        const command = `git diff ${staged ? '--staged' : ''}`;
        console.error(`[Function Call] Getting git diff with command: ${command}`);
        const { stdout, stderr } = await execAsync(command, { cwd: WORKSPACE_ROOT, timeout: 10000 });
        if (stderr)
            console.error(`[Function Call] Git diff stderr: ${stderr}`);
        const MAX_DIFF_LENGTH = 20000; // Limit output size
        return stdout.length > MAX_DIFF_LENGTH
            ? stdout.substring(0, MAX_DIFF_LENGTH) + "\n... (diff truncated)"
            : (stdout || "(no changes detected)");
    }
    catch (error) {
        console.error(`[Function Call] Error getting git diff:`, error);
        return `Error getting git diff: ${error.message}`;
    }
}
// --- Function Declarations for Vertex AI ---
export const availableFunctionDeclarations = [
    { name: "read_file_content", description: "Reads the content of a specified file within the workspace.", parameters: { type: FunctionDeclarationSchemaType.OBJECT, properties: { filePath: { type: FunctionDeclarationSchemaType.STRING, description: "Relative path to the file from the workspace root." } }, required: ['filePath'] } },
    { name: "list_directory", description: "Lists the files and subdirectories within a specified directory in the workspace.", parameters: { type: FunctionDeclarationSchemaType.OBJECT, properties: { dirPath: { type: FunctionDeclarationSchemaType.STRING, description: "Relative path to the directory from the workspace root." }, recursive: { type: FunctionDeclarationSchemaType.BOOLEAN, description: "Whether to list recursively (Note: basic implementation)." } }, required: ['dirPath'] } },
    { name: "search_codebase", description: "Searches the codebase for a specific term using ripgrep (rg) or grep. Excludes node_modules and .git.", parameters: { type: FunctionDeclarationSchemaType.OBJECT, properties: { searchTerm: { type: FunctionDeclarationSchemaType.STRING, description: "The text or pattern to search for." }, filePattern: { type: FunctionDeclarationSchemaType.STRING, description: "Optional glob pattern to filter files (e.g., '*.ts')." }, caseSensitive: { type: FunctionDeclarationSchemaType.BOOLEAN, description: "Whether the search should be case sensitive (default: false)." } }, required: ['searchTerm'] } },
    { name: "get_git_diff", description: "Gets the code changes from git diff (unstaged by default).", parameters: { type: FunctionDeclarationSchemaType.OBJECT, properties: { staged: { type: FunctionDeclarationSchemaType.BOOLEAN, description: "Whether to get staged changes only (default: false)." } } } },
];
export const functionCallingTool = { functionDeclarations: availableFunctionDeclarations };
// Map function names to implementations
export const functionImplementationMap = {
    "read_file_content": readFileContent,
    "list_directory": listDirectory,
    "search_codebase": searchCodebase,
    "get_git_diff": getGitDiff,
};
